services:
  weather-logger:
    build:
      context: ./weather-logger
      dockerfile: Dockerfile
    image: weather-logger:latest
    container_name: weather-logger
    restart: unless-stopped

    # Mount configuration and data directories
    volumes:
      # Configuration file (read-only)
      - ./config.yaml:/app/config.yaml:ro

      # Database directory (persistent)
      - ./data:/app/data

      # Logs directory (persistent)
      - ./logs:/app/logs

    # Environment variables (optional, config.yaml takes precedence)
    environment:
      # Uncomment and set these if you prefer env vars over config.yaml
      # - WEATHER_LOGGER_AMBIENT_WEATHER_API_KEY=${API_KEY}
      # - WEATHER_LOGGER_AMBIENT_WEATHER_APPLICATION_KEY=${APP_KEY}
      # - WEATHER_LOGGER_AMBIENT_WEATHER_MAC_ADDRESS=${MAC_ADDRESS}
      # - WEATHER_LOGGER_DATABASE_PATH=/app/data/weather.db
      # - WEATHER_LOGGER_LOGGING_LEVEL=INFO
      - TZ=America/Los_Angeles

    # Resource limits (optional)
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 256M
        reservations:
          cpus: '0.1'
          memory: 64M

    # Logging configuration
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

    # Health check
    healthcheck:
      test: ["CMD", "sqlite3", "/app/data/weather.db", "SELECT COUNT(*) FROM weather_measurements;"]
      interval: 5m
      timeout: 10s
      retries: 3
      start_period: 30s

  # Optional: Run the polling collector instead of realtime
  # Uncomment this service and comment out weather-logger above
  # weather-logger-polling:
  #   build:
  #     context: ./weather-logger
  #     dockerfile: Dockerfile
  #   image: weather-logger:latest
  #   container_name: weather-logger-polling
  #   restart: unless-stopped
  #   command: ["python3", "collector.py"]
  #   volumes:
  #     - ./config.yaml:/app/config.yaml:ro
  #     - ./data:/app/data
  #     - ./logs:/app/logs
  #   environment:
  #     - TZ=America/Los_Angeles

  # Automated backup scheduler
  # Daily backups to B2/S3 with tiered retention policy
  backup-scheduler:
    build:
      context: ./weather-logger
      dockerfile: Dockerfile
    image: weather-logger:latest
    container_name: weather-backup-scheduler
    restart: unless-stopped
    command: ["python3", "backup_scheduler.py"]
    volumes:
      - ./config.yaml:/app/config.yaml:ro
      - ./data:/app/data
      - ./logs:/app/logs
    environment:
      - TZ=America/Los_Angeles
    deploy:
      resources:
        limits:
          cpus: '0.2'
          memory: 128M
        reservations:
          cpus: '0.05'
          memory: 32M

  # Grafana dashboard for weather data visualization
  grafana:
    image: grafana/grafana:latest
    container_name: weather-grafana
    restart: unless-stopped
    # Run as host user to access database files
    user: "1000:1000"
    ports:
      - "3000:3000"
    volumes:
      # Mount database directory so Grafana can access SQLite
      # Note: SQLite needs write access to directory for temp files
      - ./data:/var/lib/weather-data
      # Grafana data persistence
      - grafana-data:/var/lib/grafana
      # Provisioning configs
      - ./grafana/provisioning:/etc/grafana/provisioning
    environment:
      - TZ=America/Los_Angeles
      # Install SQLite data source plugin on startup
      - GF_INSTALL_PLUGINS=frser-sqlite-datasource
      # Anonymous access (optional - disable for production)
      - GF_AUTH_ANONYMOUS_ENABLED=false
      # Admin credentials (change these!)
      - GF_SECURITY_ADMIN_USER=nate
      - GF_SECURITY_ADMIN_PASSWORD=haydencamille123
      # Fix permissions for user 1000
      - GF_PATHS_DATA=/var/lib/grafana
      - GF_PATHS_LOGS=/var/log/grafana
      - GF_PATHS_PLUGINS=/var/lib/grafana/plugins
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 256M
        reservations:
          cpus: '0.1'
          memory: 64M

  # Public Hugo blog with nginx (proxied through Cloudflare)
  # Content is built locally on macOS and rsync'd to ./public-blog directory
  static-site:
    build:
      context: ./hugo-site  # Dockerfile location in this repo
    image: static-site:latest
    container_name: static-site
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    environment:
      - TZ=America/Los_Angeles
    volumes:
      # Mount pre-built Hugo site (rsync'd from local machine)
      - ./public-blog:/usr/share/nginx/html:ro
      # Mount SSL certificates (Cloudflare origin or Let's Encrypt)
      - ./certs:/etc/nginx/certs:ro
    deploy:
      resources:
        limits:
          cpus: '0.3'
          memory: 128M
        reservations:
          cpus: '0.05'
          memory: 32M
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

  # Private house manual with basic auth (not proxied through Cloudflare)
  # Content is built locally on macOS and rsync'd to ./public-house-manual directory
  house-manual:
    build:
      context: ./house-manual  # Dockerfile location in this repo
    image: house-manual:latest
    container_name: house-manual
    restart: unless-stopped
    ports:
      - "8080:8080"
    environment:
      - TZ=America/Los_Angeles
    volumes:
      # Mount pre-built Hugo site (rsync'd from local machine)
      - ./public-house-manual:/usr/share/nginx/html:ro
    deploy:
      resources:
        limits:
          cpus: '0.2'
          memory: 64M
        reservations:
          cpus: '0.05'
          memory: 32M
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"

volumes:
  grafana-data:
